var logger = require('pomelo-logger').getLogger('pomelo', __filename);
var Parser = module.exports;

/**
 * [parse the original protos, give the paresed result can be used by protobuf encode/decode.]
 * @param  {[Object]} protos Original protos, in a js map.
 * @return {[Object]} The presed result, a js object represent all the meta data of the given protos.
 */
Parser.parse = function(protos){
	var maps = {};
	for(var key in protos){
		maps[key] = parseObject(maps, key, protos[key]);
	}

	return maps;
};

/**
 * [parse a single protos, return a object represent the result. The method can be invocked recursively.]
 * @param  {[Object]} obj The origin proto need to parse.
 * @return {[Object]} The parsed result, a js object.
 */
function parseObject(maps, key, obj){
	var proto = {};
	var nestProtos = {};
	var tags = {};

	for(var name in obj){
		var tag = obj[name];
		var params = name.split(' ');

		switch(params[0]){
			case 'message':
				if(params.length !== 2){
					logger.error(`parse protobuff message length error [need 2 find ${params.length}] on:[${name}] with: ${key} => ${JSON.stringify(obj)}.`);
					continue;
				}
				nestProtos[params[1]] = parseObject(maps, params[1], tag);
				continue;
			case 'required':
			case 'optional':
			case 'repeated':{
				//params length should be 3 and tag can't be duplicated
				if(params.length !== 3 ){
					logger.error(`parse protobuff member property length error [need 3 find ${params.length}] on:[${name}] with: ${key} => ${JSON.stringify(obj)}.`);
					continue;
				}
				if (!!tags[tag]) {
					logger.error(`parse protobuff member index duplicated [${tag}] on:[${name}] with: ${key} => ${JSON.stringify(obj)}.`);
					continue;
				}
				proto[params[2]] = {
					option : params[0],
					type : params[1],
					tag : tag
				};
				// check is valid type
				switch (params[1]) {
					case 'uInt32':
					case 'int32' :
					case 'sInt32':
					case 'float':
					case 'double':
					case 'string':
						break;
					default:
						{
							// is option type
							if (maps['message ' + params[1]]) {
								break;
							} else {
								logger.error(`parse protobuff member type error [${params[1]}] on:[${name}] with: ${key} => ${JSON.stringify(obj)}.`);
							}
						}
				}
				tags[tag] = params[2];
			}
			break;
			default: {
				logger.error(`parse protobuff member option error [${params[0]}] on:[${name}] with: ${key} => ${JSON.stringify(obj)}.`);
			}
		}
	}

	proto.__messages = nestProtos;
	proto.__tags = tags;
	return proto;
}